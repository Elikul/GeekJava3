Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
Requirements Prerequisite

Why Have Official Requirements?
An explicit set of requirements is important for several reasons.
Explicit requirements help to ensure that the user rather than the programmer drives the system’s functionality. If the requirements are explicit, the user can review them and agree to them. If they’re not, the programmer usually ends up making requirements decisions during programming. Explicit requirements keep you from guessing what the user wants. Explicit requirements also help to avoid arguments. You decide on the scope of the system before you begin programming. If you have a disagreement with another programmer about what the program is supposed to do, you can resolve it by looking at the written requirements. Paying attention to requirements helps to minimize changes to a system after development begins. If you find a coding error during coding, you change a few lines of code and work goes on. If you find a requirements error during coding, you have to alter the design to meet the changed requirement. You might have to throw away part of the old design, and because it has to accommodate code that’s already written, the new design will take longer than it would have in the first place. You also have to discard code and test cases affected by the requirement change and write new code and test cases. Even code that’s otherwise unaffected must be retested so that you can be sure the changes in other areas haven’t introduced any new errors.
Data from numerous organizations indicates that on large projects an error in requirements detected during the architecture stage is typically 3 times as expensive to correct as it would be if it were detected during the requirements stage. If detected during coding, it’s 5–10 times as expensive; during system test, 10 times; and post-release, a whopping 10–100 times as expensive as it would be if it were detected during requirements development. On smaller projects with lower administrative costs, the multiplier post-release is closer to 5–10 than 100. In either case, it isn’t money you’d want to have taken out of your salary.
Specifying requirements adequately is a key to project success, perhaps even more important than effective construction techniques. Many good books have been written about how to specify requirements well. Consequently, the next few sections don’t tell you how to do a good job of specifying requirements, they tell you how to determine whether the requirements have been done well and how to make the best of the requirements you have.

The Myth of Stable Requirements
Stable requirements are the holy grail of software development. With stable requirements, a project can proceed from architecture to design to coding to testing in a way that’s orderly, predictable, and calm. This is software heaven! You have predictable expenses, and you never have to worry about a feature costing 100 times as much to implement as it would otherwise because your user didn’t think of it until you were finished debugging. It’s fine to hope that once your customer has accepted a requirements document, no changes will be needed. On a typical project, however, the customer can’t reliably describe what is needed before the code is written. The problem isn’t that the customers are a lower life form. Just as the more you work with the project, the better you understand it, the more they work with it, the better they understand it. The development process helps customers better understand their own needs, and this is a major source of requirements changes. A plan to follow the requirements rigidly is actually a plan not to respond to your customer.
How much change is typical? Studies at IBM and other companies have found that the average project experiences about a 25 percent change in requirements during development which accounts for 70 to 85 percent of the rework on a typical project.  Maybe you think the Pontiac Aztek was the greatest car ever made, belong to the Flat Earth Society, and make a pilgrimage to the alien landing site at Roswell, New Mexico, every four years. If you do, go ahead and believe that requirements won’t change on your projects. If, on the other hand, you’ve stopped believing in Santa Claus and the Tooth Fairy, or at least have stopped admitting it, you can take several steps to minimize the impact of requirements changes.
Here are several things you can do to make the best of changing requirements during
construction:
Use the requirements checklist at the end of the section to assess the quality of your
Requirements. If your requirements aren’t good enough, stop work, back up, and
make them right before you proceed. Sure, it feels like you’re getting behind if you stop
coding at this stage. But if you’re driving from Chicago to Los Angeles, is it a waste of
time to stop and look at a road map when you see signs for New York? No. If you’re
not heading in the right direction, stop and check your course.
Make sure everyone knows the cost of requirements changes. Clients get excited
when they think of a new feature. In their excitement, their blood thins and runs to
their medulla oblongata and they become giddy, forgetting all the meetings you had to
discuss requirements, the signing ceremony, and the completed requirements document.
The easiest way to handle such feature-intoxicated people is to say, “Gee, that sounds like a great idea. Since it’s not in the requirements document, I’ll work up a
revised schedule and cost estimate so that you can decide whether you want to do it
now or later.” The words “schedule” and “cost” are more sobering than coffee and a
cold shower, and many “must haves” will quickly turn into “nice to haves.”
If your organization isn’t sensitive to the importance of doing requirements first, point
out that changes at requirements time are much cheaper than changes later. Use this
chapter’s “Utterly Compelling and Foolproof Argument for Doing Prerequisites Before
Construction.”
Set up a change-control procedure. If your client’s excitement persists, consider
establishing a formal change-control board to review such proposed changes. It’s all
right for customers to change their minds and to realize that they need more capabilities.
The problem is their suggesting changes so frequently that you can’t keep up.
Having a built-in procedure for controlling changes makes everyone happy. You’re
happy because you know that you’ll have to work with changes only at specific times.
Your customers are happy because they know that you have a plan for handling their
input.
Use development approaches that accommodate changes. Some development
approaches maximize your ability to respond to changing requirements. An evolutionary prototyping approach helps you explore a system’s requirements before you send your forces in to build it. Evolutionary delivery is an approach that delivers the system in stages. You can build a little, get a little feedback from your users, adjust your design a little, make a few changes, and build a little more. The key is using short development cycles so that you can respond to your users quickly.
Dump the project. If the requirements are especially bad or volatile and none of the
suggestions above are workable, cancel the project. Even if you can’t really cancel the
project, think about what it would be like to cancel it. Think about how much worse it
would have to get before you would cancel it. If there’s a case in which you would dump it, at least ask yourself how much difference there is between your case and that case.
Keep your eye on the business case for the project. Many requirements issues disappear
before your eyes when you refer back to the business reason for doing the project.
Requirements that seemed like good ideas when considered as “features” can seem like
terrible ideas when you evaluate the “incremental business value.” Programmers who
remember to consider the business impact of their decisions are worth their weight in
gold—although I’ll be happy to receive my commission for this advice in cash.
Architecture Prerequisite
Software architecture is the high-level part of software design, the frame that holds the
more detailed parts of the design.
Architecture is also known as “system architecture,”
“high-level design,” and “top-level design.” Typically, the architecture is
described in a single document referred to as the “architecture specification” or “toplevel design.” Some people make a distinction between architecture and high-level design—architecture refers to design constraints that apply systemwide, whereas highlevel design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.
Because this book is about construction, this section doesn’t tell you how to develop
a software architecture; it focuses on how to determine the quality of an existing architecture.
Because architecture is one step closer to construction than requirements,
however, the discussion of architecture is more detailed than the discussion of
requirements.
Why have architecture as a prerequisite? Because the quality of the architecture determines the conceptual integrity of the system. That in turn determines the ultimate
quality of the system. A well-thought-out architecture provides the structure needed to
maintain a system’s conceptual integrity from the top levels down to the bottom. It
provides guidance to programmers—at a level of detail appropriate to the skills of the
programmers and to the job at hand. It partitions the work so that multiple developers
or multiple development teams can work independently.
Good architecture makes construction easy. Bad architecture makes construction
almost impossible.
 Architectural changes are expensive to make during construction or later. The time
needed to fix an error in a software architecture is on the same order as that needed to
fix a requirements error—that is, more than that needed to fix a coding error.
Architecture changes are like requirements changes in that seemingly small changes can be far-reaching. Whether the architectural changes arise from the need to fix errors or the need to make improvements, the earlier you can identify the changes, the better.
Typical Architectural Components
Many components are common to good system architectures. If you’re building the
whole system yourself, your work on the architecture will overlap your work on the
more detailed design. In such a case, you should at least think about each architectural
component. If you’re working on a system that was architected by someone else,
you should be able to find the important components without a bloodhound, a deerstalker cap, and a magnifying glass. In either case, here are the architectural components to consider.

Program Organization
A system architecture first needs an overview that describes the system in broad
terms. Without such an overview, you’ll have a hard time building a coherent picture
from a thousand details or even a dozen individual classes. If the system were a little
12-piece jigsaw puzzle, your one-year-old could solve it between spoonfuls of strained
asparagus. A puzzle of 12 subsystems is harder to put together, and if you can’t put it
together, you won’t understand how a class you’re developing contributes to the system.
In the architecture, you should find evidence that alternatives to the final organization
were considered and find the reasons for choosing the final organization over its alternatives.
It’s frustrating to work on a class when it seems as if the class’s role in the system
has not been clearly conceived. By describing the organizational alternatives, the architecture provides the rationale for the system organization and shows that each class has been carefully considered. One review of design practices found that the design rationale is at least as important for maintenance as the design itself.
The architecture should define the major building blocks in a program. Depending on
the size of the program, each building block might be a single class or it might be a
subsystem consisting of many classes. Each building block is a class, or it’s a collection
of classes or routines that work together on high-level functions such as interacting
with the user, displaying Web pages, interpreting commands, encapsulating
business rules, or accessing data. Every feature listed in the requirements should be
covered by at least one building block. If a function is claimed by two or more building
blocks, their claims should cooperate, not conflict.
What each building block is responsible for should be well defined. A building block
should have one area of responsibility, and it should know as little as possible about
other building blocks’ areas of responsibility. By minimizing what each building block
knows about the other building blocks, you localize information about the design into
single building blocks. The communication rules for each building block should be well defined. The architecture should describe which other building blocks the building block can use directly, which it can use indirectly, and which it shouldn’t use at all.

Major Classes.
The architecture should specify the major classes to be used. It should identify the
responsibilities of each major class and how the class will interact with other classes.
It should include descriptions of the class hierarchies, of state transitions, and of
object persistence. If the system is large enough, it should describe how classes are
organized into subsystems.
The architecture should describe other class designs that were considered and give
reasons for preferring the organization that was chosen. The architecture doesn’t need
to specify every class in the system. Aim for the 80/20 rule: specify the 20 percent of
the classes that make up 80 percent of the system’s behavior.


Data Design
The architecture should describe the major files and table designs to be used. It
should describe alternatives that were considered and justify the choices that were
made. If the application maintains a list of customer IDs and the architects have chosen
to represent the list of IDs using a sequential-access list, the document should
explain why a sequential-access list is better than a random-access list, stack, or hash
table. During construction, such information gives you insight into the minds of the
architects. During maintenance, the same insight is an invaluable aid. Without it,
you’re watching a foreign movie with no subtitles.
Data should normally be accessed directly by only one subsystem or class, except
through access classes or routines that allow access to the data in controlled and
abstract ways.
The architecture should specify the high-level organization and contents of any databases used. The architecture should explain why a single database is preferable to
multiple databases (or vice versa), explain why a database is preferable to flat files,
identify possible interactions with other programs that access the same data, explain
what views have been created on the data, and so on.

Business Rules.

If the architecture depends on specific business rules, it should identify them and
describe the impact the rules have on the system’s design. For example, suppose the
system is required to follow a business rule that customer information should be no more than 30 seconds out of date. In that case, the impact that rule has on the architecture’s approach to keeping customer information up to date and synchronized
should be described.

User Interface Design.

The user interface is often specified at requirements time. If it isn’t, it should be specified in the software architecture. The architecture should specify major elements of
Web page formats, GUIs, command line interfaces, and so on. Careful architecture of
the user interface makes the difference between a well-liked program and one that’s
never used.
The architecture should be modularized so that a new user interface can be substituted
without affecting the business rules and output parts of the program. For example,
the architecture should make it fairly easy to lop off a group of interactive interface
classes and plug in a group of command line classes. This ability is often useful, especially since command line interfaces are convenient for software testing at the unit or subsystem level. The design of user interfaces deserves its own book-length discussion but is outside the scope of this book.

Resource Management.

The architecture should describe a plan for managing scarce resources such as database
connections, threads, and handles. Memory management is another important
area for the architecture to treat in memory-constrained applications areas such as
driver development and embedded systems. The architecture should estimate the
resources used for nominal and extreme cases. In a simple case, the estimates should
show that the resources needed are well within the capabilities of the intended implementation environment. In a more complex case, the application might be required to more actively manage its own resources. If it is, the resource manager should be architected as carefully as any other part of the system.

Security.
The architecture should describe the approach to design-level and code-level security. If a threat model has not previously been built, it should be built at architecture time. Coding guidelines should be developed with security implications in mind, including
approaches to handling buffers, rules for handling untrusted data (data input from users, cookies, configuration data, and other external interfaces), encryption, level of detail contained in error messages, protecting secret data that’s in memory, and other issues.

Performance.
If performance is a concern, performance goals should be specified in the requirements.
Performance goals can include resource use, in which case the goals should
also specify priorities among resources, including speed vs. memory vs. cost.
The architecture should provide estimates and explain why the architects believe the
goals are achievable. If certain areas are at risk of failing to meet their goals, the architecture should say so. If certain areas require the use of specific algorithms or data
types to meet their performance goals, the architecture should say that. The architecture
can also include space and time budgets for each class or object.

Scalability.
Scalability is the ability of a system to grow to meet future demands. The architecture
should describe how the system will address growth in number of users, number of
servers, number of network nodes, number of database records, size of database
records, transaction volume, and so on. If the system is not expected to grow and scalability is not an issue, the architecture should make that assumption explicit.

Interoperability.

If the system is expected to share data or resources with other software or hardware,
the architecture should describe how that will be accomplished.

Internationalization/Localization.

“Internationalization” is the technical activity of preparing a program to support multiple locales. Internationalization is often known as “I18n” because the first and last
characters in “internationalization” are “I” and “N” and because there are 18 letters in
the middle of the word. “Localization” (known as “L10n” for the same reason) is the
activity of translating a program to support a specific local language.
Internationalization issues deserve attention in the architecture for an interactive system.
Most interactive systems contain dozens or hundreds of prompts, status displays,
help messages, error messages, and so on. Resources used by the strings should
be estimated. If the program is to be used commercially, the architecture should show
that the typical string and character-set issues have been considered, including character set used (ASCII, DBCS, EBCDIC, MBCS, Unicode, ISO 8859, and so on), kinds
of strings used (C strings, Visual Basic strings, and so on), maintaining the strings
without changing code, and translating the strings into foreign languages with minimal
impact on the code and the user interface. The architecture can decide to use
strings in line in the code where they’re needed, keep the strings in a class and reference
them through the class interface, or store the strings in a resource file. The architecture
should explain which option was chosen and why.
Input/Output.

Input/output (I/O) is another area that deserves attention in the architecture. The
architecture should specify a look-ahead, look-behind, or just-in-time reading scheme.
And it should describe the level at which I/O errors are detected: at the field, record,
stream, or file level.
Error Processing.

Error processing is turning out to be one of the thorniest problems of modern computer
science, and you can’t afford to deal with it haphazardly. Some people have estimated
that as much as 90 percent of a program’s code is written for exceptional, errorprocessing cases or housekeeping, implying that only 10 percent is written for nominal cases (Shaw in Bentley 1982). With so much code dedicated to handling errors, a strategy for handling them consistently should be spelled out in the architecture.
Error handling is often treated as a coding-convention-level issue, if it’s treated at all.
But because it has systemwide implications, it is best treated at the architectural level.
Here are some questions to consider:

■ Is error processing corrective or merely detective? If corrective, the program can
attempt to recover from errors. If it’s merely detective, the program can continue
processing as if nothing had happened, or it can quit. In either case, it should
notify the user that it detected an error.

■ Is error detection active or passive? The system can actively anticipate errors—for
example, by checking user input for validity—or it can passively respond to them
only when it can’t avoid them—for example, when a combination of user input
produces a numeric overflow. It can clear the way or clean up the mess. Again, in
either case, the choice has user-interface implications.

■ How does the program propagate errors? Once it detects an error, it can immediately
discard the data that caused the error, it can treat the error as an error
and enter an error-processing state, or it can wait until all processing is complete
and notify the user that errors were detected (somewhere).

■ What are the conventions for handling error messages? If the architecture
doesn’t specify a single, consistent strategy, the user interface will appear to be a
confusing macaroni-and-dried-bean collage of different interfaces in different
parts of the program. To avoid such an appearance, the architecture should
establish conventions for error messages.

■ How will exceptions be handled? The architecture should address when the
code can throw exceptions, where they will be caught, how they will be logged,
how they will be documented, and so on.
■ Inside the program, at what level are errors handled? You can handle them at
the point of detection, pass them off to an error-handling class, or pass them up
the call chain.

■ What is the level of responsibility of each class for validating its input data? Is
each class responsible for validating its own data, or is there a group of classes
responsible for validating the system’s data? Can classes at any level assume that
the data they’re receiving is clean?

■ Do you want to use your environment’s built-in exception-handling mechanism
or build your own? The fact that an environment has a particular error-handling
approach doesn’t mean that it’s the best approach for your requirements.

Fault Tolerance.
The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a collection of techniques that increase a system’s reliability by detecting
errors, recovering from them if possible, and containing their bad effects if not.
For example, a system could make the computation of the square root of a number
fault tolerant in any of several ways:

■ The system might back up and try again when it detects a fault. If the first
answer is wrong, it would back up to a point at which it knew everything was all
right and continue from there.

■ The system might have auxiliary code to use if it detects a fault in the primary
code. In the example, if the first answer appears to be wrong, the system
switches over to an alternative square-root routine and uses it instead.

■ The system might use a voting algorithm. It might have three square-root classes
that each use a different method. Each class computes the square root, and then
the system compares the results. Depending on the kind of fault tolerance built
into the system, it then uses the mean, the median, or the mode of the three
results.

■ The system might replace the erroneous value with a phony value that it knows
to have a benign effect on the rest of the system.

Other fault-tolerance approaches include having the system change to a state of partial
operation or a state of degraded functionality when it detects an error. It can shut
itself down or automatically restart itself. These examples are necessarily simplistic.
Fault tolerance is a fascinating and complex subject—unfortunately, it’s one that’s outside the scope of this book.

Architectural Feasibility.

The designers might have concerns about a system’s ability to meet its performance
targets, work within resource limitations, or be adequately supported by the implementation
environments. The architecture should demonstrate that the system is
technically feasible. If infeasibility in any area could render the project unworkable,
the architecture should indicate how those issues have been investigated—through
proof-of-concept prototypes, research, or other means. These risks should be resolved
before full-scale construction begins.

Overengineering.

Robustness is the ability of a system to continue to run after it detects an error. Often
an architecture specifies a more robust system than that specified by the requirements.
One reason is that a system composed of many parts that are minimally robust
might be less robust than is required overall. In software, the chain isn’t as strong as
its weakest link; it’s as weak as all the weak links multiplied together. The architecture
should clearly indicate whether programmers should err on the side of overengineering
or on the side of doing the simplest thing that works.
Specifying an approach to overengineering is particularly important because many
programmers overengineer their classes automatically, out of a sense of professional
pride. By setting expectations explicitly in the architecture, you can avoid the phenomenon in which some classes are exceptionally robust and others are barely adequate.

Buy-vs.-Build Decisions.
The most radical solution to building software is not to build it at all—to buy it instead
or to download open-source software for free. You can buy GUI controls, database
managers, image processors, graphics and charting components, Internet communications components, security and encryption components, spreadsheet tools, textprocessing tools—the list is nearly endless. One of the greatest advantages of programming in modern GUI environments is the amount of functionality you get automatically: graphics classes, dialog box managers, keyboard and mouse handlers, code that works automatically with any printer or monitor, and so on.
If the architecture isn’t using off-the-shelf components, it should explain the ways
in which it expects custom-built components to surpass ready-made libraries and
components.
Reuse Decisions.

If the plan calls for using preexisting software, test cases, data formats, or other materials, the architecture should explain how the reused software will be made to conform to the other architectural goals—if it will be made to conform.

Change Strategy.
Because building a software product is a learning process for both the programmers
and the users, the product is likely to change throughout its development. Changes
arise from volatile data types and file formats, changed functionality, new features, and
so on. The changes can be new capabilities likely to result from planned enhancements,
or they can be capabilities that didn’t make it into the first version of the system.
Consequently, one of the major challenges facing a software architect is making
the architecture flexible enough to accommodate likely changes.
The architecture should clearly describe a strategy for handling changes. The architecture should show that possible enhancements have been considered and that the enhancements most likely are also the easiest to implement. If changes are likely in
input or output formats, style of user interaction, or processing requirements, the
architecture should show that the changes have all been anticipated and that the
effects of any single change will be limited to a small number of classes. The architecture’s plan for changes can be as simple as one to put version numbers in data files, reserve fields for future use, or design files so that you can add new tables. If a code generator is being used, the architecture should show that the anticipated changes are within the capabilities of the code generator.
The architecture should indicate the strategies that are used to delay commitment. For
example, the architecture might specify that a table-driven technique be used rather
than hard-coded if tests. It might specify that data for the table is to be kept in an external file rather than coded inside the program, thus allowing changes in the program without recompiling.

General Architectural Quality.
A good architecture specification is characterized by discussions of the classes in the
system, of the information that’s hidden in each class, and of the rationales for including and excluding all possible design alternatives.
The architecture should be a polished conceptual whole with few ad hoc additions.
The central thesis of the most popular software-engineering book ever, The Mythical
Man-Month, is that the essential problem with large systems is maintaining their conceptual integrity. A good architecture should fit the problem. When
you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn’t look as if the problem and the architecture have been forced
together with duct tape.
You might know of ways in which the architecture was changed during its development.
Each change should fit in cleanly with the overall concept. The architecture
shouldn’t look like a U.S. Congress appropriations bill complete with pork-barrel,
boondoggle riders for each representative’s home district.
The architecture’s objectives should be clearly stated. A design for a system with a primary goal of modifiability will be different from one with a goal of uncompromised
performance, even if both systems have the same function.
The architecture should describe the motivations for all major decisions. Be wary of
“we’ve always done it that way” justifications. One story goes that Beth wanted to
cook a pot roast according to an award-winning pot roast recipe handed down in her
husband’s family. Her husband, Abdul, said that his mother had taught him to sprinkle
it with salt and pepper, cut both ends off, put it in the pan, cover it, and cook it.
Beth asked, “Why do you cut both ends off?” Abdul said, “I don’t know. I’ve always
done it that way. Let me ask my mother.” He called her, and she said, “I don’t know.
I’ve always done it that way. Let me ask your grandmother.” She called his grandmother, who said, “I don’t know why you do it that way. I did it that way because it was too big to fit in my pan.”
Good software architecture is largely machine- and language-independent. Admittedly,
you can’t ignore the construction environment. By being as independent of the
environment as possible, however, you avoid the temptation to overarchitect the system
or to do a job that you can do better during construction. If the purpose of a program
is to exercise a specific machine or language, this guideline doesn’t apply.
The architecture should tread the line between underspecifying and overspecifying
the system. No part of the architecture should receive more attention than it deserves,
or be overdesigned. Designers shouldn’t pay attention to one part at the expense of
another. The architecture should address all requirements without gold-plating (without containing elements that are not required).
The architecture should explicitly identify risky areas. It should explain why they’re
risky and what steps have been taken to minimize the risk.
The architecture should contain multiple views. Plans for a house will include elevations, floor plan, framing plan, electrical diagrams, and other views of the house. Software architecture descriptions also benefit from providing different views of the
system that flush out errors and inconsistencies and help programmers fully understand the system’s design.
Finally, you shouldn’t be uneasy about any parts of the architecture. It shouldn’t contain anything just to please the boss. It shouldn’t contain anything that’s hard for you to understand. You’re the one who’ll implement it; if it doesn’t make sense to you, how can you implement it?

Amount of Time to Spend on Upstream Prerequisites.
The amount of time to spend on problem definition, requirements, and software architecture varies according to the needs of your project. Generally, a well-run project devotes about 10 to 20 percent of its effort and about 20 to 30 percent of its schedule to requirements, architecture, and up-front planning (McConnell 1998, Kruchten 2000). These figures don’t include time for detailed design—that’s part of construction.
If requirements are unstable and you’re working on a large, formal project, you’ll probably have to work with a requirements analyst to resolve requirements problems that are identified early in construction. Allow time to consult with the requirements analyst and for the requirements analyst to revise the requirements before you’ll have a
workable version of the requirements.
If requirements are unstable and you’re working on a small, informal project, you’ll probably need to resolve requirements issues yourself. Allow time for defining the requirements well enough that their volatility will have a minimal impact on construction If the requirements are unstable on any project—formal or informal—treat requirements work as its own project. Estimate the time for the rest of the project after you’ve finished the requirements. This is a sensible approach since no one can reasonably expect you to estimate your schedule before you know what you’re building. It’s as if you were a contractor called to work on a house. Your customer says, “What will it cost to do the work?” You reasonably ask, “What do you want me to do?” Your customer says, “I can’t tell you, but how much will it cost?” You reasonably thank the customer for wasting your time and go home.
With a building, it’s clear that it’s unreasonable for clients to ask for a bid before telling
you what you’re going to build. Your clients wouldn’t want you to show up with
wood, hammer, and nails and start spending their money before the architect had finished the blueprints. People tend to understand software development less than they
understand two-by-fours and sheetrock, however, so the clients you work with might
not immediately understand why you want to plan requirements development as a
separate project. You might need to explain your reasoning to them.
When allocating time for software architecture, use an approach similar to the one for
requirements development. If the software is a kind that you haven’t worked with
before, allow more time for the uncertainty of designing in a new area. Ensure that the
time you need to create a good architecture won’t take away from the time you need
for good work in other areas. If necessary, plan the architecture work as a separate
project, too.
